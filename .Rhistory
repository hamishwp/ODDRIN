}
plot_abcsmc(s, n_x, AlgoParams$smc_Npart, AlgoResults$Omega_sample_phys, Omega)
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
}
n_x <- length(Model$par_lb) #n_x = number of parameters
N_T <- AlgoParams$smc_Npart/2
tolerancetarget=1 #LOOSEEND: need to add in an adaptive stopping rule
tag<-gsub(gsub(Sys.time(),pattern = " ", replacement = "_"),pattern = ":",replacement = "")
AlgoResults <- list(
Omega_sample = array(NA, dim=c(AlgoParams$smc_Npart, n_x, AlgoParams$smc_steps)), #store sampled parameters on the transformed space
Omega_sample_phys = array(NA, dim=c(AlgoParams$smc_Npart, n_x, AlgoParams$smc_steps)), #store sampled parameters on the untransformed space
W = array(NA, dim=c(AlgoParams$smc_Npart, AlgoParams$smc_steps)), #Weights
d = array(Inf, dim=c(AlgoParams$smc_Npart, AlgoParams$Np, AlgoParams$smc_steps)), #Distances
tolerancestore=array(NA, AlgoParams$smc_steps),
essstore=array(NA, AlgoParams$smc_steps)
)
if (AlgoParams$n_nodes > 1) bcast_ODDRIN(dir, Model, AlgoParams, nslaves=AlgoParams$n_nodes-1)
start_time <- Sys.time()
if(unfinished==F){
#Initialize and perform sampling for s=1
AlgoResults <- AlgoStep1(dir, AlgoParams, AlgoResults)
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
s_start = 2 # continue the algorithm from s = 2
} else {
#Collect relevant information from the unfinished sample
UnfinishedAlgoResults <- retrieve_UnfinishedAlgoResults(dir, oldtag, AlgoParams$smc_Npart, AlgoResults)
AlgoResults <- UnfinishedAlgoResults$AlgoResults
s_start <- UnfinishedAlgoResults$s_start
n_start <- UnfinishedAlgoResults$n_start
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
}
for (s in s_start:AlgoParams$smc_steps){
#record and print time for each step
end_time <- Sys.time()
print(paste('Time:', end_time-start_time))
start_time <- Sys.time()
AlgoResults <- update_tolerance_and_weights(s, AlgoParams$smc_alpha, AlgoResults)
AlgoResults <- resample_particles(s, N_T, AlgoParams$smc_Npart, AlgoResults)
propCOV <- calc_propCOV(s, n_x, AlgoParams$smc_Npart, AlgoResults)
if(AlgoParams$n_nodes>1){
node_return <- mpi.remote.exec(perturb_particles, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes,
AlgoResults$W[,s], AlgoResults$Omega_sample[,,s], AlgoResults$Omega_sample_phys[,,s],
AlgoResults$d[,,s], propCOV, AlgoResults$tolerance[s])
particle_divisions <- split(1:AlgoParams$smc_Npart, sort(1:AlgoParams$smc_Npart%%AlgoParams$n_nodes))
for (j in 1:length(node_return)){
AlgoResults$Omega_sample[particle_divisions[[j]],,s] <- node_return[[j]]$Omega_sample_node
AlgoResults$Omega_sample_phys[particle_divisions[[j]],,s] <- node_return[[j]]$Omega_sample_phys_node
AlgoResults$d[particle_divisions[[j]],,s] <- node_return[[j]]$d_node
}
} else {
AlgoResults <- perturb_particles(s, propCOV, AlgoParams, AlgoResults)
}
plot_abcsmc(s, n_x, AlgoParams$smc_Npart, AlgoResults$Omega_sample_phys, Omega)
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
}
AlgoParams$smc_Npart <- 20
n_x <- length(Model$par_lb) #n_x = number of parameters
N_T <- AlgoParams$smc_Npart/2
tolerancetarget=1 #LOOSEEND: need to add in an adaptive stopping rule
tag<-gsub(gsub(Sys.time(),pattern = " ", replacement = "_"),pattern = ":",replacement = "")
AlgoResults <- list(
Omega_sample = array(NA, dim=c(AlgoParams$smc_Npart, n_x, AlgoParams$smc_steps)), #store sampled parameters on the transformed space
Omega_sample_phys = array(NA, dim=c(AlgoParams$smc_Npart, n_x, AlgoParams$smc_steps)), #store sampled parameters on the untransformed space
W = array(NA, dim=c(AlgoParams$smc_Npart, AlgoParams$smc_steps)), #Weights
d = array(Inf, dim=c(AlgoParams$smc_Npart, AlgoParams$Np, AlgoParams$smc_steps)), #Distances
tolerancestore=array(NA, AlgoParams$smc_steps),
essstore=array(NA, AlgoParams$smc_steps)
)
if (AlgoParams$n_nodes > 1) bcast_ODDRIN(dir, Model, AlgoParams, nslaves=AlgoParams$n_nodes-1)
start_time <- Sys.time()
if(unfinished==F){
#Initialize and perform sampling for s=1
AlgoResults <- AlgoStep1(dir, AlgoParams, AlgoResults)
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
s_start = 2 # continue the algorithm from s = 2
} else {
#Collect relevant information from the unfinished sample
UnfinishedAlgoResults <- retrieve_UnfinishedAlgoResults(dir, oldtag, AlgoParams$smc_Npart, AlgoResults)
AlgoResults <- UnfinishedAlgoResults$AlgoResults
s_start <- UnfinishedAlgoResults$s_start
n_start <- UnfinishedAlgoResults$n_start
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
}
for (s in s_start:AlgoParams$smc_steps){
#record and print time for each step
end_time <- Sys.time()
print(paste('Time:', end_time-start_time))
start_time <- Sys.time()
AlgoResults <- update_tolerance_and_weights(s, AlgoParams$smc_alpha, AlgoResults)
AlgoResults <- resample_particles(s, N_T, AlgoParams$smc_Npart, AlgoResults)
propCOV <- calc_propCOV(s, n_x, AlgoParams$smc_Npart, AlgoResults)
if(AlgoParams$n_nodes>1){
node_return <- mpi.remote.exec(perturb_particles, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes,
AlgoResults$W[,s], AlgoResults$Omega_sample[,,s], AlgoResults$Omega_sample_phys[,,s],
AlgoResults$d[,,s], propCOV, AlgoResults$tolerance[s])
particle_divisions <- split(1:AlgoParams$smc_Npart, sort(1:AlgoParams$smc_Npart%%AlgoParams$n_nodes))
for (j in 1:length(node_return)){
AlgoResults$Omega_sample[particle_divisions[[j]],,s] <- node_return[[j]]$Omega_sample_node
AlgoResults$Omega_sample_phys[particle_divisions[[j]],,s] <- node_return[[j]]$Omega_sample_phys_node
AlgoResults$d[particle_divisions[[j]],,s] <- node_return[[j]]$d_node
}
} else {
AlgoResults <- perturb_particles(s, propCOV, AlgoParams, AlgoResults)
}
plot_abcsmc(s, n_x, AlgoParams$smc_Npart, AlgoResults$Omega_sample_phys, Omega)
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
}
mpi.close.Rslaves()
n_x <- length(Model$par_lb) #n_x = number of parameters
N_T <- AlgoParams$smc_Npart/2
tolerancetarget=1 #LOOSEEND: need to add in an adaptive stopping rule
tag<-gsub(gsub(Sys.time(),pattern = " ", replacement = "_"),pattern = ":",replacement = "")
AlgoResults <- list(
Omega_sample = array(NA, dim=c(AlgoParams$smc_Npart, n_x, AlgoParams$smc_steps)), #store sampled parameters on the transformed space
Omega_sample_phys = array(NA, dim=c(AlgoParams$smc_Npart, n_x, AlgoParams$smc_steps)), #store sampled parameters on the untransformed space
W = array(NA, dim=c(AlgoParams$smc_Npart, AlgoParams$smc_steps)), #Weights
d = array(Inf, dim=c(AlgoParams$smc_Npart, AlgoParams$Np, AlgoParams$smc_steps)), #Distances
tolerancestore=array(NA, AlgoParams$smc_steps),
essstore=array(NA, AlgoParams$smc_steps)
)
if (AlgoParams$n_nodes > 1) bcast_ODDRIN(dir, Model, AlgoParams, nslaves=AlgoParams$n_nodes-1)
start_time <- Sys.time()
if(unfinished==F){
#Initialize and perform sampling for s=1
AlgoResults <- AlgoStep1(dir, AlgoParams, AlgoResults)
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
s_start = 2 # continue the algorithm from s = 2
} else {
#Collect relevant information from the unfinished sample
UnfinishedAlgoResults <- retrieve_UnfinishedAlgoResults(dir, oldtag, AlgoParams$smc_Npart, AlgoResults)
AlgoResults <- UnfinishedAlgoResults$AlgoResults
s_start <- UnfinishedAlgoResults$s_start
n_start <- UnfinishedAlgoResults$n_start
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
}
for (s in s_start:AlgoParams$smc_steps){
#record and print time for each step
end_time <- Sys.time()
print(paste('Time:', end_time-start_time))
start_time <- Sys.time()
AlgoResults <- update_tolerance_and_weights(s, AlgoParams$smc_alpha, AlgoResults)
AlgoResults <- resample_particles(s, N_T, AlgoParams$smc_Npart, AlgoResults)
propCOV <- calc_propCOV(s, n_x, AlgoParams$smc_Npart, AlgoResults)
if(AlgoParams$n_nodes>1){
node_return <- mpi.remote.exec(perturb_particles, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes,
AlgoResults$W[,s], AlgoResults$Omega_sample[,,s], AlgoResults$Omega_sample_phys[,,s],
AlgoResults$d[,,s], propCOV, AlgoResults$tolerance[s])
particle_divisions <- split(1:AlgoParams$smc_Npart, sort(1:AlgoParams$smc_Npart%%AlgoParams$n_nodes))
for (j in 1:length(node_return)){
AlgoResults$Omega_sample[particle_divisions[[j]],,s] <- node_return[[j]]$Omega_sample_node
AlgoResults$Omega_sample_phys[particle_divisions[[j]],,s] <- node_return[[j]]$Omega_sample_phys_node
AlgoResults$d[particle_divisions[[j]],,s] <- node_return[[j]]$d_node
}
} else {
AlgoResults <- perturb_particles(s, propCOV, AlgoParams, AlgoResults)
}
plot_abcsmc(s, n_x, AlgoParams$smc_Npart, AlgoResults$Omega_sample_phys, Omega)
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
}
#Initialize and perform sampling for s=1
AlgoResults <- AlgoStep1(dir, AlgoParams, AlgoResults)
AlgoResults$W[,1] <- 1/AlgoParams$smc_Npart
node_return <- mpi.remote.exec(initialise_particles, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes)
node_return
node_return <- mpi.remote.exec(initialise_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes)
node_return
perturb_particles_Rmpi <- function(dir, Npart, n_nodes, W_curr, Omega_curr, Omega_phys_curr, d_curr, propCOV, tolerance){
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[mpi.comm.rank()]]
n_allocated <- length(allocated_particles)
n_x <- length(Model$par_lb)
Omega_sample_node <- Omega_curr[allocated_particles,]
Omega_sample_phys_node <- Omega_phys_curr[allocated_particles,]
d_node <- d_curr[allocated_particles,]
for(n in 1:n_allocated){
if(W_curr[n]>0){
Omega_prop <- multvarNormProp(xt=Omega_curr[n,], propPars=propCOV) #perturb the proposal
Omega_prop_phys <- Omega_prop %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model)
d_prop <-  -logTarget(dir = dir, Model = Model,
proposed = Omega_prop_phys %>% addTransfParams(),
AlgoParams = AlgoParams) #calculate distance
acc <- sum(d_prop<tolerance)/sum(d_curr[n,]<tolerance) * modifyAcc(Omega_prop, Omega_curr[n,], Model)
u <- runif(1)
if(u < acc){
Omega_sample_node[n,] <- Omega_prop
Omega_sample_phys_node[n,] <- Omega_sample_node[n,] %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model) %>% unlist()
d_node[n,] <- d_prop
}
}
}
return(list(Omega_sample_node=Omega_sample_node,
Omega_sample_phys_node=Omega_sample_phys_node,
d_node=d_node))
}
node_return <- mpi.remote.exec(perturb_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes,
AlgoResults$W[,s], AlgoResults$Omega_sample[,,s], AlgoResults$Omega_sample_phys[,,s],
AlgoResults$d[,,s], propCOV, AlgoResults$tolerance[s])
node_return
#Initialize and perform sampling for s=1
AlgoResults <- AlgoStep1(dir, AlgoParams, AlgoResults)
node_return <- mpi.remote.exec(initialise_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes)
node_return
perturb_particles_Rmpi <- function(dir, Npart, n_nodes, W_curr, Omega_curr, Omega_phys_curr, d_curr, propCOV, tolerance){
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[mpi.comm.rank()]]
n_allocated <- length(allocated_particles)
n_x <- length(Model$par_lb)
Omega_sample_node <- Omega_curr[allocated_particles,]
Omega_sample_phys_node <- Omega_phys_curr[allocated_particles,]
d_node <- d_curr[allocated_particles,]
for(n in 1:n_allocated){
if(W_curr[n]>0){
Omega_prop <- multvarNormProp(xt=Omega_curr[n,], propPars=propCOV) #perturb the proposal
Omega_prop_phys <- Omega_prop %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model)
d_prop <-  -logTarget(dir = dir, Model = Model,
proposed = Omega_prop_phys %>% addTransfParams(),
AlgoParams = AlgoParams) #calculate distance
acc <- sum(d_prop<tolerance)/sum(d_curr[n,]<tolerance) * modifyAcc(Omega_prop, Omega_curr[n,], Model)
u <- runif(1)
if(u < acc){
Omega_sample_node[n,] <- Omega_prop
Omega_sample_phys_node[n,] <- Omega_sample_node[n,] %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model) %>% unlist()
d_node[n,] <- d_prop
}
}
}
return(list(Omega_sample_node=Omega_sample_node,
Omega_sample_phys_node=Omega_sample_phys_node,
d_node=d_node))
}
node_return <- mpi.remote.exec(initialise_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes)
node_return
n_nodes <- 2
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[mpi.comm.rank()]]
n_allocated <- length(allocated_particles)
Npart
Npart <- 20
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[mpi.comm.rank()]]
n_allocated <- length(allocated_particles)
n_nodes
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[1]]
n_allocated <- length(allocated_particles)
n_x <- length(Model$par_lb)
Omega_sample_node <- array(NA, dim=c(n_allocated, n_x))
Omega_sample_phys_node <- array(NA, dim=c(n_allocated, n_x))
d_node <- array(Inf, dim=c(n_allocated, AlgoParams$Np))
HLP <- Inf
n = 1
AlgoParams$ABC
initialise_particles_Rmpi <- function(dir, Npart, n_nodes){
# Input:
# - dir (working directory), Npart (total number of particles), n_nodes (total number of nodes)
# Output:
# - A list containing the:
#         - parameter values (on both physical and transformed space) of each particle
#         - evaluated distances for the simulated data of each particle
# Use mpi.comm.rank() to determine which particles the node has been allocated:
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[mpi.comm.rank()]]
n_allocated <- length(allocated_particles)
n_x <- length(Model$par_lb)
#create empty arrays to store parameter values and distances:
Omega_sample_node <- array(NA, dim=c(n_allocated, n_x))
Omega_sample_phys_node <- array(NA, dim=c(n_allocated, n_x))
d_node <- array(Inf, dim=c(n_allocated, AlgoParams$Np))
for (n in 1:n_allocated){
HLP <- Inf
#Sample from the parameter ranges until the higher level prior is satisfied:
while (HLP > AlgoParams$ABC){
Omega_sample_i <- runif(n_x, min=Model$par_lb, max=Model$par_ub) %>% relist(skeleton=Model$skeleton) %>% Physical2Proposed(Model) %>% unlist()
Omega_sample_phys_i <-  Omega_sample_i %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model) %>% unlist()
HLP = Model$HighLevelPriors(Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),Model)
}
#calculate distance
d_i <- -logTarget(dir = dir, Model = Model,
proposed = Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),
AlgoParams = AlgoParams)
Omega_sample_node[n,] = Omega_sample_i
Omega_sample_phys_node[n,] = Omega_sample_phys_i
d_node[n,] = d_i
}
return(list(Omega_sample_node=Omega_sample_node,
Omega_sample_phys_node=Omega_sample_phys_node,
d_node=d_node))
}
node_return <- mpi.remote.exec(initialise_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes)
node_return
while (HLP > AlgoParams$ABC){
Omega_sample_i <- runif(n_x, min=Model$par_lb, max=Model$par_ub) %>% relist(skeleton=Model$skeleton) %>% Physical2Proposed(Model) %>% unlist()
Omega_sample_phys_i <-  Omega_sample_i %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model) %>% unlist()
HLP = Model$HighLevelPriors(Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),Model)
}
Omega_sample_phys_i
d_i <- -logTarget(dir = dir, Model = Model,
proposed = Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),
AlgoParams = AlgoParams)
Omega_sample_node[n,] = Omega_sample_i
Omega_sample_phys_node[n,] = Omega_sample_phys_i
d_node[n,] = d_i
d_i
initialise_particles_Rmpi <- function(dir, Npart, n_nodes){
# Input:
# - dir (working directory), Npart (total number of particles), n_nodes (total number of nodes)
# Output:
# - A list containing the:
#         - parameter values (on both physical and transformed space) of each particle
#         - evaluated distances for the simulated data of each particle
# Use mpi.comm.rank() to determine which particles the node has been allocated:
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[mpi.comm.rank()]]
n_allocated <- length(allocated_particles)
n_x <- length(Model$par_lb)
#create empty arrays to store parameter values and distances:
Omega_sample_node <- array(NA, dim=c(n_allocated, n_x))
Omega_sample_phys_node <- array(NA, dim=c(n_allocated, n_x))
d_node <- array(Inf, dim=c(n_allocated, AlgoParams$Np))
for (n in 1:n_allocated){
HLP <- Inf
#Sample from the parameter ranges until the higher level prior is satisfied:
while (HLP > AlgoParams$ABC){
Omega_sample_i <- runif(n_x, min=Model$par_lb, max=Model$par_ub) %>% relist(skeleton=Model$skeleton) %>% Physical2Proposed(Model) %>% unlist()
Omega_sample_phys_i <-  Omega_sample_i %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model) %>% unlist()
HLP = Model$HighLevelPriors(Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),Model)
}
#calculate distance
dist_sample <- sampleDist(dir = dir,Model = Model,
proposed = AlgoResults$Omega_sample_phys[n,,1] %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),
AlgoParams = AlgoParams)
AlgoResults$d[n,,1] <- logTarget2(dist_sample)
dist_sample <- sampleDist(dir = dir, Model = Model,
proposed = Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),
AlgoParams = AlgoParams)
d_node[n,] = logTarget2(dist_sample)
Omega_sample_node[n,] = Omega_sample_i
Omega_sample_phys_node[n,] = Omega_sample_phys_i
}
return(list(Omega_sample_node=Omega_sample_node,
Omega_sample_phys_node=Omega_sample_phys_node,
d_node=d_node))
}
perturb_particles_Rmpi <- function(dir, Npart, n_nodes, W_curr, Omega_curr, Omega_phys_curr, d_curr, propCOV, tolerance){
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[mpi.comm.rank()]]
n_allocated <- length(allocated_particles)
n_x <- length(Model$par_lb)
Omega_sample_node <- Omega_curr[allocated_particles,]
Omega_sample_phys_node <- Omega_phys_curr[allocated_particles,]
d_node <- d_curr[allocated_particles,]
for(n in 1:n_allocated){
if(W_curr[n]>0){
Omega_prop <- multvarNormProp(xt=Omega_curr[n,], propPars=propCOV) #perturb the proposal
Omega_prop_phys <- Omega_prop %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model)
dist_sample <-  sampleDist(dir = dir, Model = Model,
proposed = Omega_prop_phys %>% addTransfParams(),
AlgoParams = AlgoParams)
d_prop <- logTarget2(dist_sample)
acc <- sum(d_prop<tolerance)/sum(d_curr[n,]<tolerance) * modifyAcc(Omega_prop, Omega_curr[n,], Model)
u <- runif(1)
if(u < acc){
Omega_sample_node[n,] <- Omega_prop
Omega_sample_phys_node[n,] <- Omega_sample_node[n,] %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model) %>% unlist()
d_node[n,] <- d_prop
}
}
}
return(list(Omega_sample_node=Omega_sample_node,
Omega_sample_phys_node=Omega_sample_phys_node,
d_node=d_node))
}
initialise_particles_Rmpi <- function(dir, Npart, n_nodes){
# Input:
# - dir (working directory), Npart (total number of particles), n_nodes (total number of nodes)
# Output:
# - A list containing the:
#         - parameter values (on both physical and transformed space) of each particle
#         - evaluated distances for the simulated data of each particle
# Use mpi.comm.rank() to determine which particles the node has been allocated:
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[mpi.comm.rank()]]
n_allocated <- length(allocated_particles)
n_x <- length(Model$par_lb)
#create empty arrays to store parameter values and distances:
Omega_sample_node <- array(NA, dim=c(n_allocated, n_x))
Omega_sample_phys_node <- array(NA, dim=c(n_allocated, n_x))
d_node <- array(Inf, dim=c(n_allocated, AlgoParams$Np))
for (n in 1:n_allocated){
HLP <- Inf
#Sample from the parameter ranges until the higher level prior is satisfied:
while (HLP > AlgoParams$ABC){
Omega_sample_i <- runif(n_x, min=Model$par_lb, max=Model$par_ub) %>% relist(skeleton=Model$skeleton) %>% Physical2Proposed(Model) %>% unlist()
Omega_sample_phys_i <-  Omega_sample_i %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model) %>% unlist()
HLP = Model$HighLevelPriors(Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),Model)
}
#calculate distance
dist_sample <- sampleDist(dir = dir,Model = Model,
proposed = AlgoResults$Omega_sample_phys[n,,1] %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),
AlgoParams = AlgoParams)
AlgoResults$d[n,,1] <- logTarget2(dist_sample)
dist_sample <- sampleDist(dir = dir, Model = Model,
proposed = Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),
AlgoParams = AlgoParams)
d_node[n,] = logTarget2(dist_sample)
Omega_sample_node[n,] = Omega_sample_i
Omega_sample_phys_node[n,] = Omega_sample_phys_i
}
return(list(Omega_sample_node=Omega_sample_node,
Omega_sample_phys_node=Omega_sample_phys_node,
d_node=d_node))
}
node_return <- mpi.remote.exec(initialise_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes)
node_return
if (AlgoParams$n_nodes > 1) bcast_ODDRIN(dir, Model, AlgoParams, nslaves=AlgoParams$n_nodes-1)
if (AlgoParams$n_nodes > 1) mpi.close.Rslaves()
n_x <- length(Model$par_lb) #n_x = number of parameters
N_T <- AlgoParams$smc_Npart/2
tolerancetarget=1 #LOOSEEND: need to add in an adaptive stopping rule
tag<-gsub(gsub(Sys.time(),pattern = " ", replacement = "_"),pattern = ":",replacement = "")
AlgoResults <- list(
Omega_sample = array(NA, dim=c(AlgoParams$smc_Npart, n_x, AlgoParams$smc_steps)), #store sampled parameters on the transformed space
Omega_sample_phys = array(NA, dim=c(AlgoParams$smc_Npart, n_x, AlgoParams$smc_steps)), #store sampled parameters on the untransformed space
W = array(NA, dim=c(AlgoParams$smc_Npart, AlgoParams$smc_steps)), #Weights
d = array(Inf, dim=c(AlgoParams$smc_Npart, AlgoParams$Np, AlgoParams$smc_steps)), #Distances
tolerancestore=array(NA, AlgoParams$smc_steps),
essstore=array(NA, AlgoParams$smc_steps)
)
if (AlgoParams$n_nodes > 1) bcast_ODDRIN(dir, Model, AlgoParams, nslaves=AlgoParams$n_nodes-1)
AlgoResults <- AlgoStep1(dir, AlgoParams, AlgoResults)
saveRDS(AlgoResults, paste0(dir,"IIDIPUS_Results/abcsmc_",tag))
s_start = 2 # continue the algorithm from s = 2
AlgoResults$W[,1] <- 1/AlgoParams$smc_Npart # Give each particle an equal weight
node_return <- mpi.remote.exec(initialise_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes)
node_return
AlgoParams$AllParallel
if (AlgoParams$n_nodes > 1) bcast_ODDRIN(dir, Model, AlgoParams, nslaves=AlgoParams$n_nodes)
if (AlgoParams$n_nodes > 1) mpi.close.Rslaves()
if (AlgoParams$n_nodes > 1) bcast_ODDRIN(dir, Model, AlgoParams, nslaves=AlgoParams$n_nodes)
AlgoResults$W[,1] <- 1/AlgoParams$smc_Npart # Give each particle an equal weight
node_return <- mpi.remote.exec(initialise_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes)
node_return
Model$DestDam_modifiers
initialise_particles_Rmpi <- function(dir, Npart, n_nodes){
# Input:
# - dir (working directory), Npart (total number of particles), n_nodes (total number of nodes)
# Output:
# - A list containing the:
#         - parameter values (on both physical and transformed space) of each particle
#         - evaluated distances for the simulated data of each particle
# Use mpi.comm.rank() to determine which particles the node has been allocated:
particle_divisions <- split(1:Npart, sort(1:Npart%%n_nodes))
allocated_particles <- particle_divisions[[mpi.comm.rank()]]
n_allocated <- length(allocated_particles)
n_x <- length(Model$par_lb)
#create empty arrays to store parameter values and distances:
Omega_sample_node <- array(NA, dim=c(n_allocated, n_x))
Omega_sample_phys_node <- array(NA, dim=c(n_allocated, n_x))
d_node <- array(Inf, dim=c(n_allocated, AlgoParams$Np))
for (n in 1:n_allocated){
HLP <- Inf
#Sample from the parameter ranges until the higher level prior is satisfied:
while (HLP > AlgoParams$ABC){
Omega_sample_i <- runif(n_x, min=Model$par_lb, max=Model$par_ub) %>% relist(skeleton=Model$skeleton) %>% Physical2Proposed(Model) %>% unlist()
Omega_sample_phys_i <-  Omega_sample_i %>% relist(skeleton=Model$skeleton) %>% unlist()%>% Proposed2Physical(Model) %>% unlist()
HLP = Model$HighLevelPriors(Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),Model)
}
#calculate distance
dist_sample <- sampleDist(dir = dir, Model = Model,
proposed = Omega_sample_phys_i %>% relist(skeleton=Model$skeleton) %>% addTransfParams(),
AlgoParams = AlgoParams)
d_node[n,] = logTarget2(dist_sample)
Omega_sample_node[n,] = Omega_sample_i
Omega_sample_phys_node[n,] = Omega_sample_phys_i
}
return(list(Omega_sample_node=Omega_sample_node,
Omega_sample_phys_node=Omega_sample_phys_node,
d_node=d_node))
}
mpi.bcast.Robj2slave(initialise_particles_Rmpi)
node_return <- mpi.remote.exec(initialise_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes)
node_return
particle_divisions <- split(1:AlgoParams$smc_Npart, sort(1:AlgoParams$smc_Npart%%AlgoParams$n_nodes))
for (j in 1:length(node_return)){
AlgoResults$Omega_sample[particle_divisions[[j]],,1] <- node_return[[j]]$Omega_sample_node
AlgoResults$Omega_sample_phys[particle_divisions[[j]],,1] <- node_return[[j]]$Omega_sample_phys_node
AlgoResults$d[particle_divisions[[j]],,1] <- node_return[[j]]$d_node
}
AlgoResults
AlgoResults$tolerancestore[1] <- max(AlgoResults$d[,,1]) + 1 #set tolerance to larger than maximum distance
s_start
s <- 2
end_time <- Sys.time()
print(paste('Time:', end_time-start_time))
start_time <- Sys.time()
AlgoResults <- update_tolerance_and_weights(s, AlgoParams$smc_alpha, AlgoResults)
AlgoResults <- resample_particles(s, N_T, AlgoParams$smc_Npart, AlgoResults)
propCOV <- calc_propCOV(s, n_x, AlgoParams$smc_Npart, AlgoResults)
if(AlgoParams$n_nodes>1){
node_return <- mpi.remote.exec(perturb_particles_Rmpi, dir, AlgoParams$smc_Npart, AlgoParams$n_nodes,
AlgoResults$W[,s], AlgoResults$Omega_sample[,,s], AlgoResults$Omega_sample_phys[,,s],
AlgoResults$d[,,s], propCOV, AlgoResults$tolerance[s])
particle_divisions <- split(1:AlgoParams$smc_Npart, sort(1:AlgoParams$smc_Npart%%AlgoParams$n_nodes))
for (j in 1:length(node_return)){
AlgoResults$Omega_sample[particle_divisions[[j]],,s] <- node_return[[j]]$Omega_sample_node
AlgoResults$Omega_sample_phys[particle_divisions[[j]],,s] <- node_return[[j]]$Omega_sample_phys_node
AlgoResults$d[particle_divisions[[j]],,s] <- node_return[[j]]$d_node
}
} else {
AlgoResults <- perturb_particles(s, propCOV, AlgoParams, AlgoResults)
}
plot_abcsmc(s, n_x, AlgoParams$smc_Npart, AlgoResults$Omega_sample_phys, Omega)
