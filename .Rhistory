pnonull = 3,
betaDistr = 1,
hazDistr = "weibull",
hazParams = c(res_paramW$a, res_paramW$lambda),
seed = 1,
d = 0)
plot(1:50, listCoxSim$TC, col=ifelse(listCoxSim$delta==T, 'red', 'black'))
listCoxSim$delta
listCoxSim <- modelSim(model = "cox",
matDistr = "unif",
matParam = c(-1,1),
n = 50,
p = 3,
pnonull = 3,
betaDistr = 1,
hazDistr = "weibull",
hazParams = c(res_paramW$a, res_paramW$lambda),
seed = 1,
d = 1500)
plot(1:50, listCoxSim$TC, col=ifelse(listCoxSim$delta==T, 'red', 'black'))
listCoxSim$delta # censorship indicator
n_cov <- 3
n <- 50
beta <- c(1,2,-1)
covariates <- array(runif(n*n_cov,-1,1), dim=c(n, n_cov))
covariates
beta %*% covariates
exp(covariates %*% beta)
(- log(1- runif(n, 0,1)) /exp(covariates %*% beta))
n_cov <- 3
n <- 50
beta <- c(1,2,-1)
a <- 1
lambda <- 10
covariates <- array(runif(n*n_cov,-1,1), dim=c(n, n_cov))
h_t <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
T <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
Times <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
Times
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
n_cov <- 3
n <- 50
beta <- c(1,2,-1)
a <- 0.5
lambda <- 10
covariates <- array(runif(n*n_cov,-1,1), dim=c(n, n_cov))
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
n_cov <- 3
n <- 50
beta <- c(1,2,-1)
a <- 2
lambda <- 0.1
covariates <- array(runif(n*n_cov,-1,1), dim=c(n, n_cov))
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
Times <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
Times
plot(1:50, ST, col=ifelse(listCoxSim$delta==T, 'red', 'black'))
ST <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
plot(1:50, ST, col=ifelse(listCoxSim$delta==T, 'red', 'black'))
hist(ST)
n_cov <- 3
n <- 50
beta <- c(1,2,-1)
a <- 2
lambda <- 0.1
covariates <- array(runif(n*n_cov,-1,1), dim=c(n, n_cov))
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
ST <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
plot(1:50, ST, col=ifelse(listCoxSim$delta==T, 'red', 'black'))
hist(ST)
plot(1:50, ST, col=ifelse(listCoxSim$delta==T, 'red', 'black'))
hist(ST, breaks=15)
censor_times <- runif(n, 0, 20)
ST_censored <- ifelse(ST>censor_times, ST, censor_times)
ST_censored
plot(ST_censored)
points(censor_times, col='red')
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
# H_0(t) = lambda * t^a
ST <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
censor_times <- runif(n, 0, 10)
ST_censored <- ifelse(ST>censor_times, ST, censor_times)
plot(ST_censored)
points(censor_times, col='red')
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
# H_0(t) = lambda * t^a
ST <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
censor_times <- runif(n, 0, 30)
ST_censored <- ifelse(ST>censor_times, ST, censor_times)
plot(ST_censored)
points(censor_times, col='red')
plot(ST)
ST>censor_times
which(ST_censored == censor_times)
ST
ifelse(ST>censor_times, ST, censor_times)
ST>censor_times
ST
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
# H_0(t) = lambda * t^a
ST <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
censor_times <- runif(n, 0, 30)
ST_censored <- array(n)
for (ev in 1:n){
ST_censored[i] <- ifelse(ST[i]>censor_times[i], ST[i], censor_times[i])
}
plot(ST_censored)
points(censor_times, col='red')
_cov <- 3
n <- 50
beta <- c(1,2,-1)
a <- 2
lambda <- 0.1
covariates <- array(runif(n*n_cov,-1,1), dim=c(n, n_cov))
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
# H_0(t) = lambda * t^a
ST <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
censor_times <- runif(n, 0, 30)
ST_censored <- array(n)
for (ev in 1:n){
ST_censored[i] <- ifelse(ST[i]>censor_times[i], ST[i], censor_times[i])
}
plot(ST_censored)
n_cov <- 3
n <- 50
beta <- c(1,2,-1)
a <- 2
lambda <- 0.1
covariates <- array(runif(n*n_cov,-1,1), dim=c(n, n_cov))
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
# H_0(t) = lambda * t^a
ST <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
censor_times <- runif(n, 0, 30)
ST_censored <- array(n)
for (ev in 1:n){
ST_censored[ev] <- ifelse(ST[ev]>censor_times[ev], ST[ev], censor_times[ev])
}
plot(ST_censored)
points(censor_times, col='red')
n = 1
n = 50
ev = 1
ST[ev]
censor_times[ev]
ST[ev]>censor_times[ev]
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
# H_0(t) = lambda * t^a
ST <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
censor_times <- runif(n, 0, 30)
ST_censored <- ifelse(ST<censor_times, ST, censor_times)
plot(ST_censored)
points(censor_times, col='red')
plot(seq(0,10,0.1), lambda * seq(0,10,0.1)^a)
# H_0(t) = lambda * t^a
ST <- ((- log(1- runif(n, 0,1)) /exp(covariates %*% beta)) / lambda)^(1/a)
censor_times <- runif(n, 0, 20)
ST_censored <- ifelse(ST<censor_times, ST, censor_times)
plot(ST_censored)
points(censor_times, col='red')
censor_flag <- ifelse(censor_times==ST_censored, T, F)
censor_flag
censor_times==ST_censored
censor_flag <- censor_times==ST_censored
censor_flag
install.packages(c("survival", "survminer"))
library("survival"); library("survminer")
install.packages(c("survival", "survminer"))
library("survival"); library("survminer")
?coxph
coxph(ST ~ covariates[,1])
ST
Surv(time=ST, status=censor_flag)
?Surv
Surv(time=ST)
coxph(Surv(time=ST) ~ covariates[,1])
beta
coxph(Surv(time=ST) ~ covariates[,1] + covariates[,2] + covariates[,3])
coxph(Surv(time=ST, status=ifelse(ST_censored, 0, 1)) ~ covariates[,1] + covariates[,2] + covariates[,3])
coxph(Surv(ST, ifelse(ST_censored, 0, 1)) ~ covariates[,1] + covariates[,2] + covariates[,3])
coxph(Surv(ST, event=ifelse(ST_censored, 0, 1)) ~ covariates[,1] + covariates[,2] + covariates[,3])
coxph(Surv(time=ST, event=ifelse(ST_censored, 0, 1)) ~ covariates[,1] + covariates[,2] + covariates[,3])
coxph(Surv(time=ST) ~ covariates[,1] + covariates[,2] + covariates[,3])
# Where is the main folder with all the code and data
dir<-directory<-"/home/manderso/Documents/GitHub/ODDRIN/"
# Set the working directory from your environment variables
setwd(directory)
# Directory of the Data for Good data, e.g. Disaster Mapping, 4G connectivity, etc
FBdirectory<-'/home/patten/Documents/IDMC/Facebook_Data/'
# Do you want only the reduced packages or all? Choose via packred
packred<-F
library(testthat)
source('RCode/GetEnv.R')
# Download and install the necessary packages:
source('RCode/GetODDPackages.R')
# Sourcing the data:
source('RCode/GetData.R')
# Extract model functions and priors
source('RCode/Model.R')
# Extract the model parameterisation algorithm, default = Adaptive MCMC
source('RCode/Method.R')
#Extract the functions for generating the simulations
source('RCode/Simulate.R')
#provide the model with a parameterisation
Omega <- list(Lambda1 = list(nu=8,omega=0.4),
Lambda2 = list(nu= 9.5, omega=0.6),
Lambda3 = list(nu=7.5,omega=0.4),
Lambda4 = list(nu=9, omega=0.4),
Pdens = list(M=0.01988616, k = 6.473428),
dollar = list(M = -0.41271, k = 6.473428),
theta = list(e=0.2359788),
eps = list(eps=0.01304351))
expect_lt(Model$HighLevelPriors(Omega %>% add_Loc_Params, Model), 0.1)
#Check that DispX returns a numeric LL for a single simulated ODD object
folderin <- paste0(dir, "IIDIPUS_SimInput/ODDobjects/")
ODDSim_file <- list.files(path=folderin,pattern=Model$haz,recursive = T,ignore.case = T)[1]
ODDSim <- readRDS(paste0(folderin, ODDSim_file))
DispX_LL <- DispX(ODD = ODDSim,Omega = Omega %>% add_Loc_Params(),center = Model$center, BD_params = Model$BD_params, LL = T,Method = AlgoParams)
AlgoParams$Np
AlgoParams$Np <- 5
dist_sample <- sampleDist(dir = dir,Model = Model, proposed = Omega %>% add_Loc_Params(), AlgoParams = AlgoParams)
dist_sample
#Check that Higher Level Priors evaluated at given parameterisation are close to zero (less than 0.1)
expect_lt(Model$HighLevelPriors(Omega %>% add_Loc_Params, Model), 0.1)
Model$HighLevelPriors(Omega %>% add_Loc_Params, Model)
AlgoParams$AllParallel <- T
dist_sample <- sampleDist(dir = dir,Model = Model, proposed = Omega %>% add_Loc_Params(), AlgoParams = AlgoParams)
library(abind)
dist_sample <- sampleDist(dir = dir,Model = Model, proposed = Omega %>% add_Loc_Params(), AlgoParams = AlgoParams)
dist_sample
dist_sample$BDDists
folderin <- paste0(dir, "IIDIPUS_SimInput/BDobjects/")
BDSim_file <- list.files(path=folderin,pattern=Model$haz,recursive = T,ignore.case = T)[1]
BDSim <- readRDS(paste0(folderin, BDSim_file))
BDSim
folderin <- paste0(dir, "IIDIPUS_SimInput/BDobjects/")
BDSim_file <- list.files(path=folderin,pattern=Model$haz,recursive = T,ignore.case = T)[1]
BDSim <- readRDS(paste0(folderin, BDSim_file))
BDX_LL <- BDX(BD = BDSim,Omega = Omega %>% add_Loc_Params(),Model = Model,Method=AlgoParams, LL=T)
BDX_LL <- BDX(BD = BDSim,Omega = Omega %>% add_Loc_Params(),Model = Model,Method=AlgoParams, LL=F)
BD = BDSim
Omega = Omega %>% add_Loc_Params()
hrange<-grep("hazMean",names(BD),value = T)
if(!LL) {notnans<-which(!(is.na(BD@data$Population) | is.na(BD@data$ISO3C) | is.na(BD@data$GDP)) | all(is.na(BD@data[,hrange])))
} else notnans<-which(!(is.na(BD@data$Population) | is.na(BD@data$ISO3C) | is.na(BD@data$GDP) |
is.na(BD@data$grading) | all(is.na(BD@data[,hrange]))))
if(nrow(BD) ==0){
if(LL){return(0)}
else return(BD)
}
BD<-BD[notnans,] ;notnans<-1:nrow(BD)
LL <- F
hrange<-grep("hazMean",names(BD),value = T)
if(!LL) {notnans<-which(!(is.na(BD@data$Population) | is.na(BD@data$ISO3C) | is.na(BD@data$GDP)) | all(is.na(BD@data[,hrange])))
} else notnans<-which(!(is.na(BD@data$Population) | is.na(BD@data$ISO3C) | is.na(BD@data$GDP) |
is.na(BD@data$grading) | all(is.na(BD@data[,hrange]))))
if(nrow(BD) ==0){
if(LL){return(0)}
else return(BD)
}
BD<-BD[notnans,] ;notnans<-1:nrow(BD)
Params<-FormParams(BD,list(Np=Method$Np,center=Model$center))
# Income distribution percentiles & extract income percentile
SincN<-seq(20,90,by = 10); Sinc<-ExtractCIndy(BD,var = paste0("p",SincN,"p100"))
# Load buildings file
# buildings<-readRDS(BD@buildingsfile)
# Sample income distribution by area*building height?
# BD%<>%SampleBuildings(buildings,F)
# Calculate non-local linear predictor values
LP<-GetLP(BD,Omega,Params,Sinc,notnans)
# for each building in list,
CalcBD<-function(ij){
iso3c<-BD@data$ISO3C[ij]
# Calculate local linear predictor (NOTE: is a scalar - we randomly sample one value)
locallinp<-tryCatch(sample(LP$dGDP$linp[LP$dGDP$ind==LP$iGDP[ij]],size=Method$Np, replace=TRUE)*
LP$Plinp[ij]*LP$linp[[iso3c]],         error=function(e) NA) #LOOSEEND: Assumes that a house is equally likely to be from each income bracket.
#locallinp<- LP$dGDP$linp[5]* LP$Plinp[ij]*LP$linp[[iso3c]]
# if(is.na(locallinp)) stop(ij)
# locallinp<-1.
bDamage<-0
bDamage<-rep(0, Method$Np) #0 = notaffected, 1 = damaged, 2 = destroyed
ind <- 1:Method$Np
for(h in hrange){
if(length(BD@data[ij,h])==0) next
if(is.na(BD@data[ij,h])) next
if(length(ind)==0) break
# calculate the sampled hazard intensity I_ij
# I_ij<-rnorm(n = Method$Np,
#             mean = BD@data[ij,h],
#             sd = BD@data[ij,paste0("hazSD",h)]/10)
I_ij<-BD@data[ij,h]
Damage <-fDamUnscaled(I_ij[ind],list(I0=Params$I0, Np=Params$Np),Omega)*locallinp
D_DestDam <- D_DestDam_calc(Damage, Omega)
D_DestDamUnaf <- rbind(D_DestDam, 1-colSums(D_DestDam))
bDamage[ind] <- pmax(bDamage[ind], apply(D_DestDamUnaf, 2, sample, x=2:0, size=1, replace=F)) #note that positional matching of arguments to sample
#is overridden by matching names
ind <- which(bDamage != 2)
}
bPred <- ifelse(bDamage == 0, 'notaffected', 'Damaged')
if(LL) return(bPred==BD@data$grading[ij]) #return 1 if correctly classified
if(sim == F){
if(BD@data$grading[ij] == 'notaffected'){
return(ifelse(bPred == 'notaffected', 'Correctly classified notaffected', 'Incorrectly classified damaged'))
} else {
return(ifelse(bPred == 'notaffected', 'Incorrectly classified notaffected', 'Correctly classified damaged'))
}
}
if(sim == T) return(bPred)
}
Method <- AlgoParams
Params<-FormParams(BD,list(Np=Method$Np,center=Model$center))
# Income distribution percentiles & extract income percentile
SincN<-seq(20,90,by = 10); Sinc<-ExtractCIndy(BD,var = paste0("p",SincN,"p100"))
# Load buildings file
# buildings<-readRDS(BD@buildingsfile)
# Sample income distribution by area*building height?
# BD%<>%SampleBuildings(buildings,F)
# Calculate non-local linear predictor values
LP<-GetLP(BD,Omega,Params,Sinc,notnans)
# for each building in list,
CalcBD<-function(ij){
iso3c<-BD@data$ISO3C[ij]
# Calculate local linear predictor (NOTE: is a scalar - we randomly sample one value)
locallinp<-tryCatch(sample(LP$dGDP$linp[LP$dGDP$ind==LP$iGDP[ij]],size=Method$Np, replace=TRUE)*
LP$Plinp[ij]*LP$linp[[iso3c]],         error=function(e) NA) #LOOSEEND: Assumes that a house is equally likely to be from each income bracket.
#locallinp<- LP$dGDP$linp[5]* LP$Plinp[ij]*LP$linp[[iso3c]]
# if(is.na(locallinp)) stop(ij)
# locallinp<-1.
bDamage<-0
bDamage<-rep(0, Method$Np) #0 = notaffected, 1 = damaged, 2 = destroyed
ind <- 1:Method$Np
for(h in hrange){
if(length(BD@data[ij,h])==0) next
if(is.na(BD@data[ij,h])) next
if(length(ind)==0) break
# calculate the sampled hazard intensity I_ij
# I_ij<-rnorm(n = Method$Np,
#             mean = BD@data[ij,h],
#             sd = BD@data[ij,paste0("hazSD",h)]/10)
I_ij<-BD@data[ij,h]
Damage <-fDamUnscaled(I_ij[ind],list(I0=Params$I0, Np=Params$Np),Omega)*locallinp
D_DestDam <- D_DestDam_calc(Damage, Omega)
D_DestDamUnaf <- rbind(D_DestDam, 1-colSums(D_DestDam))
bDamage[ind] <- pmax(bDamage[ind], apply(D_DestDamUnaf, 2, sample, x=2:0, size=1, replace=F)) #note that positional matching of arguments to sample
#is overridden by matching names
ind <- which(bDamage != 2)
}
bPred <- ifelse(bDamage == 0, 'notaffected', 'Damaged')
if(LL) return(bPred==BD@data$grading[ij]) #return 1 if correctly classified
if(sim == F){
if(BD@data$grading[ij] == 'notaffected'){
return(ifelse(bPred == 'notaffected', 'Correctly classified notaffected', 'Incorrectly classified damaged'))
} else {
return(ifelse(bPred == 'notaffected', 'Incorrectly classified notaffected', 'Correctly classified damaged'))
}
}
if(sim == T) return(bPred)
}
#LOOSEEND: This should be moved outside of BDX and have the BD objects resaved without possibly the damaged buildings
possiblyDamaged_ij <- which(BD@data$grading=='possible')
possiblyDamaged_ij
notnans <- notnans[!notnans %in% possiblyDamaged_ij]
notnans
ij <- 1
iso3c<-BD@data$ISO3C[ij]
# Calculate local linear predictor (NOTE: is a scalar - we randomly sample one value)
locallinp<-tryCatch(sample(LP$dGDP$linp[LP$dGDP$ind==LP$iGDP[ij]],size=Method$Np, replace=TRUE)*
LP$Plinp[ij]*LP$linp[[iso3c]],         error=function(e) NA) #LOOSEEND: Assumes that a house is equally likely to be from each income bracket.
#locallinp<- LP$dGDP$linp[5]* LP$Plinp[ij]*LP$linp[[iso3c]]
# if(is.na(locallinp)) stop(ij)
# locallinp<-1.
bDamage<-0
bDamage<-rep(0, Method$Np) #0 = notaffected, 1 = damaged, 2 = destroyed
ind <- 1:Method$Np
for(h in hrange){
if(length(BD@data[ij,h])==0) next
if(is.na(BD@data[ij,h])) next
if(length(ind)==0) break
# calculate the sampled hazard intensity I_ij
# I_ij<-rnorm(n = Method$Np,
#             mean = BD@data[ij,h],
#             sd = BD@data[ij,paste0("hazSD",h)]/10)
I_ij<-BD@data[ij,h]
Damage <-fDamUnscaled(I_ij[ind],list(I0=Params$I0, Np=Params$Np),Omega)*locallinp
D_DestDam <- D_DestDam_calc(Damage, Omega)
D_DestDamUnaf <- rbind(D_DestDam, 1-colSums(D_DestDam))
bDamage[ind] <- pmax(bDamage[ind], apply(D_DestDamUnaf, 2, sample, x=2:0, size=1, replace=F)) #note that positional matching of arguments to sample
#is overridden by matching names
ind <- which(bDamage != 2)
}
bPred <- ifelse(bDamage == 0, 'notaffected', 'Damaged')
notnans
if(!LL) {notnans<-which(!(is.na(BD@data$Population) | is.na(BD@data$ISO3C) | is.na(BD@data$GDP)) | all(is.na(BD@data[,hrange])))
} else notnans<-which(!(is.na(BD@data$Population) | is.na(BD@data$ISO3C) | is.na(BD@data$GDP) |
is.na(BD@data$grading) | all(is.na(BD@data[,hrange]))))
notnans
ij = 1
iso3c<-BD@data$ISO3C[ij]
# Calculate local linear predictor (NOTE: is a scalar - we randomly sample one value)
locallinp<-tryCatch(sample(LP$dGDP$linp[LP$dGDP$ind==LP$iGDP[ij]],size=Method$Np, replace=TRUE)*
LP$Plinp[ij]*LP$linp[[iso3c]],         error=function(e) NA) #LOOSEEND: Assumes that a house is equally likely to be from each income bracket.
#locallinp<- LP$dGDP$linp[5]* LP$Plinp[ij]*LP$linp[[iso3c]]
# if(is.na(locallinp)) stop(ij)
# locallinp<-1.
bDamage<-0
bDamage<-rep(0, Method$Np) #0 = notaffected, 1 = damaged, 2 = destroyed
ind <- 1:Method$Np
hrange
h <- 'hazMean1'
if(length(BD@data[ij,h])==0) next
if(is.na(BD@data[ij,h])) next
if(length(ind)==0) break
# calculate the sampled hazard intensity I_ij
# I_ij<-rnorm(n = Method$Np,
#             mean = BD@data[ij,h],
#             sd = BD@data[ij,paste0("hazSD",h)]/10)
I_ij<-BD@data[ij,h]
Damage <-fDamUnscaled(I_ij[ind],list(I0=Params$I0, Np=Params$Np),Omega)*locallinp
I_ij
I_ij[ind]
fDamUnscaled(I_ij,list(I0=Params$I0, Np=Params$Np),Omega)*locallinp
setMethod("BDX", "BD", function(BD,Omega,Model,Method=list(Np=20,cores=8),LL=T, sim=F){
# Only calculate buildings with all key parameters
hrange<-grep("hazMean",names(BD),value = T)
if(!LL) {notnans<-which(!(is.na(BD@data$Population) | is.na(BD@data$ISO3C) | is.na(BD@data$GDP)) | all(is.na(BD@data[,hrange])))
} else notnans<-which(!(is.na(BD@data$Population) | is.na(BD@data$ISO3C) | is.na(BD@data$GDP) |
is.na(BD@data$grading) | all(is.na(BD@data[,hrange]))))
if(nrow(BD) ==0){
if(LL){return(0)}
else return(BD)
}
BD<-BD[notnans,] ;notnans<-1:nrow(BD)
# Get parameters for model
Params<-FormParams(BD,list(Np=Method$Np,center=Model$center))
# Income distribution percentiles & extract income percentile
SincN<-seq(20,90,by = 10); Sinc<-ExtractCIndy(BD,var = paste0("p",SincN,"p100"))
# Load buildings file
# buildings<-readRDS(BD@buildingsfile)
# Sample income distribution by area*building height?
# BD%<>%SampleBuildings(buildings,F)
# Calculate non-local linear predictor values
LP<-GetLP(BD,Omega,Params,Sinc,notnans)
# for each building in list,
CalcBD<-function(ij){
iso3c<-BD@data$ISO3C[ij]
# Calculate local linear predictor (NOTE: is a scalar - we randomly sample one value)
locallinp<-tryCatch(sample(LP$dGDP$linp[LP$dGDP$ind==LP$iGDP[ij]],size=Method$Np, replace=TRUE)*
LP$Plinp[ij]*LP$linp[[iso3c]],         error=function(e) NA) #LOOSEEND: Assumes that a house is equally likely to be from each income bracket.
#locallinp<- LP$dGDP$linp[5]* LP$Plinp[ij]*LP$linp[[iso3c]]
# if(is.na(locallinp)) stop(ij)
# locallinp<-1.
bDamage<-0
bDamage<-rep(0, Method$Np) #0 = notaffected, 1 = damaged, 2 = destroyed
ind <- 1:Method$Np
for(h in hrange){
if(length(BD@data[ij,h])==0) next
if(is.na(BD@data[ij,h])) next
if(length(ind)==0) break
# calculate the sampled hazard intensity I_ij
# I_ij<-rnorm(n = Method$Np,
#             mean = BD@data[ij,h],
#             sd = BD@data[ij,paste0("hazSD",h)]/10)
I_ij<-BD@data[ij,h]
Damage <-fDamUnscaled(I_ij,list(I0=Params$I0, Np=Params$Np),Omega)*locallinp
D_DestDam <- D_DestDam_calc(Damage, Omega)
D_DestDamUnaf <- rbind(D_DestDam, 1-colSums(D_DestDam))
bDamage[ind] <- pmax(bDamage[ind], apply(D_DestDamUnaf, 2, sample, x=2:0, size=1, replace=F)) #note that positional matching of arguments to sample
#is overridden by matching names
ind <- which(bDamage != 2)
}
bPred <- ifelse(bDamage == 0, 'notaffected', 'Damaged')
if(LL) return(bPred==BD@data$grading[ij]) #return 1 if correctly classified
if(sim == F){
if(BD@data$grading[ij] == 'notaffected'){
return(ifelse(bPred == 'notaffected', 'Correctly classified notaffected', 'Incorrectly classified damaged'))
} else {
return(ifelse(bPred == 'notaffected', 'Incorrectly classified notaffected', 'Correctly classified damaged'))
}
}
if(sim == T) return(bPred)
}
#LOOSEEND: This should be moved outside of BDX and have the BD objects resaved without possibly the damaged buildings
possiblyDamaged_ij <- which(BD@data$grading=='possible')
notnans <- notnans[!notnans %in% possiblyDamaged_ij]
if(LL) { #return the proportion of buildings correctly classified
if(Method$cores>1) {return(colMeans(t(matrix(unlist(mclapply(X = notnans,FUN = CalcBD,mc.cores = Method$cores)),ncol=length(notnans)))))
} else return(colMeans(t(matrix(unlist(lapply(X = notnans,FUN = CalcBD)),ncol=length(notnans)))))
}
# classified<-t(matrix(unlist(mclapply(X = notnans,FUN = predBD,mc.cores = Method$cores)),ncol=length(notnans)))
classified<-t(matrix(unlist(lapply(X = notnans,FUN = CalcBD)),ncol=length(notnans)))
CCN <- colSums(classified=='Correctly classified notaffected')
CCD <- colSums(classified=='Correctly classified damaged')
ICN <- colSums(classified=='Incorrectly classified notaffected')
ICD <- colSums(classified=='Incorrectly classified damaged')
if(Method$Np != 1){ return(rbind(CCN, CCD, ICN, ICD))} #If Np = 1, assumes that we are simulating data
# Save into the file
BD$ClassPred<-classified
return(BD)
})
BDX_LL <- BDX(BD = BDSim,Omega = Omega %>% add_Loc_Params(),Model = Model,Method=AlgoParams, LL=F)
BDX_LL
dist_sample <- sampleDist(dir = dir,Model = Model, proposed = Omega %>% add_Loc_Params(), AlgoParams = AlgoParams)
dist_sample
d <- logTarget2(dist_sample)
d
expect_equal(NCOL(DispX_LL$BDDists), AlgoParams$Np)
expect_equal(NCOL(dist_sample$BDDists), AlgoParams$Np)
expect_equal(length(dist_sample$Disps), AlgoParams$Np)
expect_equal(length(d), AlgoParams$Np)
dist_sample <- sampleDist(dir = dir,Model = Model, proposed = Omega %>% add_Loc_Params(), AlgoParams = AlgoParams)
dist_sample
d <- logTarget2(dist_sample)
d
